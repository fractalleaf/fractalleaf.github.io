Title: Project Euler problem 4 - Largest palindrome product
Date: 2018-07-19 17:30
Category: Project Euler
Tags: palindrome, project euler, python
related_posts: 
Slug: project-euler-problem-4
Authors: Søren
Summary: Solution to the fourth Project Euler problem. Finding the largest palindromic number, which is a product between two 3-digit numbers.

[Link to problem on Project Euler homepage](https://projecteuler.net/problem=4)

[Link to Github repository](https://github.com/fractalleaf/project-euler/tree/master/p004)

## Description

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is $9009 = 91 \times 99$.

Find the largest palindrome made from the product of two 3-digit numbers.

## Brute force
In the simplest brute force solution to the problem one simply iterates over all products between 3-digit numbers to find the largest palindrome


```python
def get_digits(n):
    """get digits of a number. Return as list"""
    digits = []
    while True:
        n, digit = divmod(n, 10)
        digits.append(digit)
        if n == 0:
            break

    return digits

def is_palindrome(n):
    """Check if a number is a palindrome"""
    digits = get_digits(n)
    ln = len(digits)
    for i in range(ln//2):
        if digits[i] != digits[ln-1-i]:
            return False
    return True

def p004(ndigit):
    ulimit = 10**ndigit # upper limit
    llimit = 10**(ndigit-1) # lower limit

    mx = 0 # biggest palindrome found so far

    for n1 in range(llimit, ulimit):
        for n2 in range(n1, ulimit):

            if is_palindrome(n1*n2) and n1*n2 > mx:
                mx = n1*n2

    return mx

print("Ndigits = 2")
print("Result for ndigit = 2: {}".format(p004(2)))
%timeit p004(2)
print("")
print("Ndigits = 3")
%timeit p004(3)
```

    Ndigits = 2
    Result for ndigit = 2: 9009
    5.07 ms ± 159 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
    
    Ndigits = 3
    647 ms ± 1.39 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)


## Optimisation

The most obvious optimisation of the brute force solution is to iterate "backwards" from large to small 3-digit numbers, and to avoid iterating over products that are smaller than the largest palindrome found so far.


```python
def p004(ndigit):
    ulimit = 10**ndigit - 1 # upper limit
    llimit = 10**(ndigit-1) - 1 # lower limit

    mx = 0 # biggest palindrome found so far

    # iterate backwards to encounter largest palindrome sooner
    for n1 in range(ulimit, llimit, -1):
        for n2 in range(ulimit, n1-1, -1):

            # if n1*n2 is smaller than largest palindrome it will continue to
            # be so becaue n2 is decreasing
            if n1*n2 <= mx:
                break

            if is_palindrome(n1*n2):
                mx = n1*n2

    return mx

print("Ndigits = 2")
print("Result for ndigit = 2: {}".format(p004(2)))
%timeit p004(2)
print("")
print("Ndigits = 3")
%timeit p004(3)
```

    Ndigits = 2
    Result for ndigit = 2: 9009
    74.1 µs ± 289 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
    
    Ndigits = 3
    5.8 ms ± 38.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)


This simple optimisation improves the runtime by roughly a factor of 100.
