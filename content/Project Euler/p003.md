Title: Project Euler problem 3 - Largest prime factor
Date: 2018-07-16 18:00
Category: Project Euler
Tags: prime numbers, project euler, python, trial division
related_posts: 
Slug: project-euler-problem-3
Authors: Søren
Summary: Solution to the third Project Euler problem. Finding the largest prime factor of an integer.

[Link to problem on Project Euler homepage](https://projecteuler.net/problem=3)

[Link to Github repository](https://github.com/fractalleaf/project-euler/tree/master/p003)

## Description

The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143?

## Solution
The simplest algorithm for solving the problem is [trial division](https://en.wikipedia.org/wiki/Trial_division).

Trial division is an integer factorisation algorithm that finds all prime factors of an integer, $n$, by finding divisors amongst smaller integers. A simple implementation of the algorithm (returning only the largest prime factor) is


```python
LOW_LIMIT = 13195
HIGH_LIMIT = 600851475143

def p003(n):
    """Find largest prime factor of n by trial division"""
    factor = 2
    while factor <= n:
        if n % factor == 0:
            n //= factor
        else:
            factor += 1

    return factor

print("Result for n == {}: {}".format(LOW_LIMIT, p003(LOW_LIMIT)))

%timeit p003(HIGH_LIMIT)
```

    Result for n == 13195: 29
    649 µs ± 17.2 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)


The factors that divides `n` in line 9 are always prime. This is because if the factor was composite its prime constituents would have been divided with `n` in an earlier iteration.

## Optimisation

The trial division algorithm can be optimised in a couple of ways.

First, any integer, $n$, can have at most one prime factor larger than $\sqrt{n}$, and it is therefore only necessary to test for trial factors up to $\sqrt{n}$. Any remaining factor above $\sqrt{n}$ will be prime (since, it would have been previously divided out otherwise).

Second, the only one even prime is 2. By dividing $n$ by 2 until it becomes odd, afterwards it is only necessary to test odd trial factors, halving the number of iterations.


```python
def p003(n):
    """Find largest prime factor of n by trial division"""
    factor = 2
    while n % factor == 0:
        n //= factor

    factor = 3
    while factor*factor <= n:
        if n % factor == 0:
            n //= factor
        else:
            factor += 2

    return n

print("Result for n == {}: {}".format(LOW_LIMIT, p003(LOW_LIMIT)))

%timeit p003(HIGH_LIMIT)
```

    Result for n == 13195: 29
    99 µs ± 2.35 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)


With these optimisations the runtime is improved by a factor of six.

## Conclusions
Trial division is not generally the best algorithm to use for prime factorisation, but in cases such as the one at hand where there are only small prime factors, it performs well.

For prime factorisation of larger integers it can still be advantageous to use trial division to test for divisibility by small primes before switching over to a more specialised algorithm.
